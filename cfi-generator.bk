package main

// This file will read a YAML file provided as an argument and generate a Nuclei template file based on the data in the YAML file.
// Example usage:
// go run cfi-generator.go yaml/CCC.OS.yaml nuclei GCP

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

// YAMLData represents the structure of the input YAML file.
type YAMLData struct {
	ID       string    `yaml:"id"`
	Title    string    `yaml:"title"`
	Version  string    `yaml:"version"`
	Controls []Control `yaml:"controls"`
}

// Control represents the structure of each control within the YAML file.
type Control struct {
	ID               string              `yaml:"id"`
	FeatureID        string              `yaml:"feature_id"`
	Title            string              `yaml:"title"`
	Objective        string              `yaml:"objective"`
	NISTCSF          string              `yaml:"nist_csf"`
	MITREAttack      string              `yaml:"mitre_attack"`
	ControlMappings  map[string][]string `yaml:"control_mappings"`
	TestRequirements map[string]string   `yaml:"test_requirements"`
}

// NucleiTemplate represents the structure of the Nuclei template file.
type NucleiTemplate struct {
	ID   string `yaml:"id"`
	Info Info   `yaml:"info"`
	Code []Code `yaml:"code"`
}

// Info represents the structure of the info section within the Nuclei template file.
type Info struct {
	Name     string `yaml:"name"`
	Severity string `yaml:"severity"`
	Author   string `yaml:"author"`
}

// Code represents the structure of the code section within the Nuclei template file.
type Code struct {
	Engine   []string `yaml:"engine"`
	Source   string   `yaml:"source"`
	Matchers []struct {
		Type  string   `yaml:"type"`
		Words []string `yaml:"words"`
	} `yaml:"matchers"`
}

func main() {
	// exit with a warning if no arguments are provided
	if len(os.Args) < 2 {
		log.Fatalf("[ERROR] Please provide a YAML file path as an argument.")
	}

	// if optional second arg is provided, use it as the output directory
	outputDir := "."
	if len(os.Args) > 2 {
		outputDir = os.Args[2]
	}

	// open file
	yamlFile, err := ioutil.ReadFile(os.Args[1])
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	// Unmarshal the YAML file into a struct
	var data YAMLData
	err = yaml.Unmarshal(yamlFile, &data)
	if err != nil {
		log.Fatalf("error: %v", err)
	}

	// convert the YAML data into Nuclei template format
	nucleiTemplate := NucleiTemplate{
		Info: Info{
			Severity: "info",
			Author:   "FINOS",
		},
		Code: []Code{},
	}
	var buffer bytes.Buffer
	yamlEncoder := yaml.NewEncoder(&buffer)
	yamlEncoder.SetIndent(2)

	// iterate over each control and create a code section in the Nuclei template for each test requirement
	for _, control := range data.Controls {
		controlID := fmt.Sprintf("%s_%s", os.Args[3], strings.Replace(control.ID, ".", "_", -1))
		nucleiTemplate.ID = controlID
		nucleiTemplate.Info.Name = data.Title + ": " + control.Title

		for testID := range control.TestRequirements {
			code := Code{
				Engine: []string{"zsh"},
				Source: fmt.Sprintf("~/dev/nuclei-demo/bin/gcp/gcs/gcs-1.42.0 %s_%s", controlID, testID),
				Matchers: []struct {
					Type  string   `yaml:"type"`
					Words []string `yaml:"words"`
				}{
					{
						Type:  "word",
						Words: []string{"FAIL", "ERROR"},
					},
				},
			}
			nucleiTemplate.Code = append(nucleiTemplate.Code, code)
		}
		// Create or open the file based on the YAML id value
		mdFile, err := os.Create(fmt.Sprintf("%s/%s.yaml", outputDir, controlID))
		if err != nil {
			log.Fatalf("error: %v", err)
		}
		defer mdFile.Close()

		// Marshal the Nuclei template struct into YAML format
		yamlEncoder.Encode(nucleiTemplate)
		if err != nil {
			log.Fatalf("error: %v", err)
		}

		// Write the YAML content to the file
		_, err = mdFile.Write(buffer.Bytes())
		if err != nil {
			log.Fatalf("error: %v", err)
		}
	}

}
